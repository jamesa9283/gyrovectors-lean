import basic.conventional

/-
A groupoid (G, ⊕) is a gyrogroup if its binary operation satisfies the following axioms.
* In G there is at least one element, 0, called a left identity, satisfying
(G1) 0⊕a = a for all a ∈ G. 
* There is an element 0 ∈ G satisfying axiom (G1) such that for each a ∈ G there is an element 
⊖a ∈ G, called a left inverse of a, satisfying
(G2) ⊖a⊕a = 0
* Moreover, for any a, b, c ∈ G there exists a unique element gyr[a, b]c ∈ G such that the binary 
operation obeys the left gyroassociative law
(G3) a⊕(b⊕c) = (a⊕b)⊕gyr[a, b]c
* The map gyr[a, b] : G → G given by c 7→ gyr[a, b]c is an automorphism of the groupoid (G, ⊕),
(G4) gyr[a, b] ∈ Aut(G, ⊕)
and the automorphism gyr[a, b] of G is called the gyroautomorphism of G,
generated by a, b ∈ G. The operation gyr : G × G → Aut(G, ⊕) is called
the gyrooperation of G. 
* Finally, the gyroautomorphism gyr[a, b] generated by any a, b ∈ G possesses the left loop property
(G5) gyr[a, b] = gyr[a⊕b, b]
-/

class gyrogroup (G : Type) extends has_gyrop G, has_subgyrop G, has_neggyrop G, has_zero G :=
-- axiom 1: 0 ⊕ a = a
(zero_gyro : ∀ (a : G), 0 ⊙ a = a)
-- axiom 2: ⊖a⊕a = 0
(gyr_add_left_neg : ∀ (a : G), ⊝a ⊙ a = 0)
(gyr : G → G → G → G) -- gyr a b c is gyr[a, b]c in the notation from the Wiki
-- axiom 3: ∀ a b c ∈ G, a + (b + c) = (a + b) + gyr a b c
(add_gyr_assoc : ∀ a b c, a ⊙ (b ⊙ c) = (a ⊙ b) ⊙ gyr a b c)
(add_gyr_assoc_inj : ∀ a b c d, a ⊙ (b ⊙ c) = (a ⊙ b) ⊙ d → d = gyr a b c) -- uniqueness
-- axiom 4: gyr a b ∈ Aut (G, ⊙) 
(gyr_bijective : ∀ a b, function.bijective (gyr a b))
(map_gyrop : ∀ a b c d, gyr a b (c ⊙ d) = gyr a b c ⊙ gyr a b d )
-- axiom 5: gyr a b = gyr (a + b) b
(gyr_loop : ∀ a b, gyr a b = gyr (a ⊙ b) b)

-- axiom 4 has been removed and is going to be a seperate function, see below
variables (G : Type) [gyrogroup G]
variables (a b c d : G)

@[simp] lemma zero_gyro : ∀ (a : G), 0 ⊙ a = a := gyrogroup.zero_gyro
@[simp] lemma gyr_add_left_neg : ∀ (a : G), ⊝a ⊙ a = 0 := gyrogroup.gyr_add_left_neg
lemma add_gyr_assoc : ∀ (a b c : G), a ⊙ (b ⊙ c) = (a ⊙ b) ⊙ gyrogroup.gyr a b c := gyrogroup.add_gyr_assoc
lemma add_gyr_assoc_inj : ∀ (a b c d : G), a ⊙ (b ⊙ c) = (a ⊙ b) ⊙ d → d = gyrogroup.gyr a b c := gyrogroup.add_gyr_assoc_inj 
lemma gyr_bijective : ∀ (a b : G), function.bijective (gyrogroup.gyr a b) := gyrogroup.gyr_bijective
@[simp] lemma map_gyrop : ∀ (a b c d : G), gyrogroup.gyr a b (c ⊙ d) = gyrogroup.gyr a b c ⊙ gyrogroup.gyr a b d  := gyrogroup.map_gyrop
@[simp] lemma gyr_loop : ∀ (a b : G), gyrogroup.gyr a b = gyrogroup.gyr (a ⊙ b) b := gyrogroup.gyr_loop
